[ { "title": "프로그래머를 위한 선형대수(3)", "url": "/posts/%EC%84%A0%ED%98%95%EB%8C%80%EC%88%98(3)/", "categories": "개인공부", "tags": "선형대수", "date": "2022-07-05 00:00:00 +0900", "snippet": "Notice프로그래머를 위한 선형대수 &lt;히라오카 카즈유키, 호리 겐&gt;, &lt;이창신&gt;, &lt;길벗&gt;을 바탕으로 공부한 내용임을 밝힙니다.3.1 LU분해주어진 행렬 $A$에 대해 $A$를 하삼각행렬$L$과 상삼각행렬 $U$의 곱으로 나타내는 것을 $LU$분해라고 한다." }, { "title": "프로그래머를 위한 선형대수(2)", "url": "/posts/%EC%84%A0%ED%98%95%EB%8C%80%EC%88%98(2)/", "categories": "개인공부", "tags": "선형대수", "date": "2022-07-05 00:00:00 +0900", "snippet": "Notice프로그래머를 위한 선형대수 &lt;히라오카 카즈유키, 호리 겐&gt;, &lt;이창신&gt;, &lt;길벗&gt;을 바탕으로 공부한 내용임을 밝힙니다.2.1 정칙성과 역행렬‘역행렬이 존재하는 정방행렬 A’를 ‘정칙행렬’이라고 합니다. 정칙이 아닌 행렬은 ‘특이행렬’이라고 합니다.가우스 요르단(Gauss - Jordan) 소거법으로 연립방정식을 풀 수 있다.\\[(A | y) = \\begin{pmatrix} 2 &amp; 3 &amp; 3 &amp; 9 \\\\ 3&amp;4&amp;2&amp;9\\\\-2&amp;-2&amp;3&amp;2 \\end{pmatrix} \\rightarrow \\begin{pmatrix} 1 &amp; 3\\over2 &amp; 3\\over2 &amp; |{9\\over2} \\\\ 3&amp;4&amp;2&amp;|9\\\\-2&amp;-2&amp;3&amp;|2 \\end{pmatrix}\\]\\[\\rightarrow \\begin{pmatrix} 1 &amp; 3\\over2 &amp; 3\\over2 &amp; |{9\\over2} \\\\ 0&amp;-{1 \\over 2} &amp; -{5\\over2} &amp;|-{9 \\over2}\\\\0&amp;1&amp;6&amp;|11 \\end{pmatrix} \\rightarrow \\begin{pmatrix} 1 &amp; 3\\over2 &amp; 3\\over2 &amp; |{9\\over2} \\\\ 0&amp;1&amp;5&amp;|9\\\\0&amp;1&amp;6&amp;|11 \\end{pmatrix}\\]\\[\\rightarrow \\begin{pmatrix} 1&amp;0&amp;-6&amp;|-9 \\\\ 0&amp;1&amp;5&amp;|9\\\\0&amp;0&amp;1&amp;|2 \\end{pmatrix} \\rightarrow \\begin{pmatrix} 1&amp;0&amp;0&amp;|3 \\\\ 0&amp;1&amp;0&amp;|-1\\\\0&amp;0&amp;1&amp;|2 \\end{pmatrix}\\]이렇게 $x = (3,-1,2)^T$을 구할 수 있다.연립일차방정식이 풀리면 역행렬도 구할 수 있다. 우선 n차 정방행렬 $A$의 역행렬이란 $AX = I$가 되는 정방행렬 $X$다. $X$를 $X = (x_1,x_2,x_3,…,x_n)$과 같이 열벡터로 나타내고, 이에 대응하여 단위행렬 $I$도 $I=(e_1,e_2,e_3,…,e_n)$으로 나타내자. 그러면 ei는 i성분만 1이고, 다른 성분은 0인 벡터가 된다.즉, $AX_i = e_i$로 나타낼 수 있다.\\[(A | I) = \\begin{pmatrix} 2&amp;3&amp;3&amp;|1&amp;0&amp;0 \\\\ 3&amp;4&amp;2&amp;|0&amp;1&amp;0\\\\-2&amp;-2&amp;3&amp;|0&amp;0&amp;1\\end{pmatrix} \\rightarrow \\begin{pmatrix} 1&amp;3\\over2&amp;3\\over2&amp;|{1\\over2}&amp;0&amp;0 \\\\ 3&amp;4&amp;2&amp;|0&amp;1&amp;0\\\\-2&amp;-2&amp;3&amp;|0&amp;0&amp;1\\end{pmatrix}\\]\\[\\rightarrow \\begin{pmatrix} 1&amp;3\\over2&amp;3\\over2&amp;|{1\\over2}&amp;0&amp;0 \\\\ 0&amp;-{1\\over2}&amp;-{5\\over2}&amp;| -{3\\over2}&amp;1&amp;0\\\\0&amp;1&amp;6&amp;|1&amp;0&amp;1\\end{pmatrix} \\rightarrow \\begin{pmatrix} 1&amp;3\\over2&amp;3\\over2&amp;|{1\\over2}&amp;0&amp;0 \\\\ 0&amp;1&amp;5&amp;| 3&amp;-2&amp;0\\\\0&amp;1&amp;6&amp;|1&amp;0&amp;1\\end{pmatrix}\\]\\[\\rightarrow \\begin{pmatrix} 1&amp;3\\over2&amp;3\\over2&amp;|{1\\over2}&amp;0&amp;0 \\\\ 0&amp;1&amp;5&amp;| 3&amp;-2&amp;0\\\\0&amp;1&amp;6&amp;|1&amp;0&amp;1\\end{pmatrix}\\rightarrow \\begin{pmatrix} 1&amp;0&amp;6&amp;|-4&amp;3&amp;0 \\\\ 0&amp;1&amp;5&amp;| 3&amp;-2&amp;0\\\\0&amp;0&amp;1&amp;|-2&amp;2&amp;1\\end{pmatrix}\\]\\[\\rightarrow \\begin{pmatrix} 1&amp;0&amp;0&amp;|-16&amp;15&amp;6 \\\\ 0&amp;1&amp;0&amp;| 13&amp;-12&amp;5\\\\0&amp;0&amp;1&amp;|-2&amp;2&amp;1\\end{pmatrix}\\]따라서 $A^{-1} = \\begin{pmatrix} -16&amp;15&amp;6&amp; \\ 13&amp;-12&amp;-5&amp;\\-2&amp;2&amp;1&amp; \\end{pmatrix}$가 된다.2.2 성질이 나쁜 경우원래보다 낮은 차원으로 이동하는 사상 A에 의해 $Ax = o$으로 이동해 오는 것과 같은 x의 집합을 A의 ‘핵(kernel)’이라고 하고, $Ker A$라고 표현한다. $Ker A$는 ‘사상 A에서 납작하게 눌러지는 방향’을 나타낸다. 그러므로 $Ker A$에 평행인 성분은 이동점만으로 특정지을 수 없다. 납작하게 눌리지 않는 경우는 0차원(원점$o$ 단 한 점 뿐)뿐이다.반대로 원래보다 높은 차원으로 이동하는 사상$B$에 대해 $x$를 여러모로 움직인 경우에 $B$로 옮기는 $y = Bx$의 집합을 $B$의 ‘상(image)’이라고 하고, $Im B$라고 표현한다. 다르게 표현하면 원래 공간 전체를 $B$로 옮긴 영역을 말한다.같은 차원에서 이동하는 경우에도 사상에 의해 공간이 납작하게 눌려버리는 경우가 있다.$C = \\begin{pmatrix} 0.8&amp;-0.6 \\ 0.4&amp;-0.3\\end{pmatrix}$는 정방행렬이지만 그 사상에서는 공간이 납작하게 눌려버린다. 즉, 차원의 크기는 상관이 없다. 본질은 ‘핵 $Ker A$나 상 $Im A$가 어떻게 되었는가’이다.결국 포인트는 2가지다. 같은 결과 $y$가 나오는 원인 $x$는 유일한가 어떤 결과$y$에도 그것이 나오는 원인$x$가 존재하는가전자가 성립하는 경우 ‘사상 $y = Ax$는 단사다’, 후자가 성립하는 경우 ‘사상 $y = Ax$는 전사다’ 또, 양자가 성립하는 경우는 ‘사상 $y=Ax$는 전단사다’$m\\times n$ 행렬 $A$에 대해 $dim\\ Ker\\ A + dim\\ Im\\ A = n$ 을 변형하여 $n - dim\\ Ker \\ A = dim\\ Im\\ A$로 표현할 수 있는데, 이는 ‘원래의 n차원 공간에서 $Ker A$의 차원 부분이 납작하게 눌리고, 남은 것이 $Im \\ A$의 차원 부분’이라고 해석할 수 있다. 예를 들면, 원래의 3차원 공간에서 1차원 부분이 눌리면 남는 것은 2차원 부분, 2차원 부분이 눌리면 남는 것은 1차원 부분이다.여기서 ‘납작하게 눌린다’는 쉽게 말하면 ‘서로 다른 $x$와 $x^\\prime$가 같은 $y$로 이동한다’는 것이다. $x = (x_1,….,x_n)^{T}$, $x\\prime = x\\prime_1,….,x\\prime_n)^{T}$, $A = (a_1,….,a_n)$일 때, $Ax = Ax \\prime$이다.$\\begin{pmatrix} a_1,\\cdots,a_n\\end{pmatrix}\\begin{pmatrix} x_1,\\cdots,x_n\\end{pmatrix}^{T} = \\begin{pmatrix} a_1,\\cdots,a_n\\end{pmatrix}\\begin{pmatrix} x_1 \\prime,\\cdots,x_n\\prime\\end{pmatrix}^{T}$과 같으니, 이런 경우에 $a_1,…,a_n$은 ‘선형 종속’이라고 한다. 반대로 선형 종속이 아닌 경우는 ‘선형독립’이라고 한다. ‘일차 종속’,’일차독립’,이라고 하거나 ‘종속’,’독립’이라고도 한다.또한, 수 $u_1,…,u_n$에 대하여 $u_1a_1+…+u_na_n = o$ 라면 ‘$u_1=…=u_n=0$’이라는 조건이 성립할 때, 벡터 $a_1,…,a_n$은 선형독립이라고 할 수 있다.여기서 ‘기저’의 조건을 재정립할 수 있다. ‘기저 벡터들은 선형독립이 아니면 안된다’는 것이다. 또한 3차원의 정의도 ‘선형독립인 벡터가 최대 n개 까지 취할 수 있다면 그 공간은 n차원’이라고도 할 수 있다.$A$를 $m\\times n$행렬이라고 가정하자, $n$차원 벡터를 $m$차원 벡터 $y = Ax$에 옮기는 사상을 생각하는 것이다. 여기서 상 $Im\\ A$의 차원 $dim \\ Im \\ A$에는 ‘행렬A의 랭크(rank)’라는 이름이 붙는다.랭크는 기본적으로 $rank\\ A \\le m,n$이다. 또한, 정칙행렬을 곱해도 랭크는 변하지 않는다. 즉, $P,Q$가 정칙이면 $rank(PA) = rank \\ A, rank(AQ) = rank \\ A$이다. 정칙행렬은 ‘납작하게 누르지 않는’ 변환이므로 A를 시행하기 전이나 후에 Q나 P를 두어도 눌리는 3차원 수, 남는 차원수는 변하지 않는다. 전치해도 rank는 달라지지 않는다.$A$의 랭크를 구하는 방법은 $Im \\ A$ = $span[a_1,…,a_n]$이므로 $span[a_1,…,a_n]$의 차원이 $rank \\ A$라고 할 수 있다." }, { "title": "프로그래머를 위한 선형대수(1)", "url": "/posts/%EC%84%A0%ED%98%95%EB%8C%80%EC%88%98(1)/", "categories": "개인공부", "tags": "선형대수", "date": "2022-07-05 00:00:00 +0900", "snippet": "Notice프로그래머를 위한 선형대수 &lt;히라오카 카즈유키, 호리 겐&gt;, &lt;이창신&gt;, &lt;길벗&gt;을 바탕으로 공부한 내용임을 밝힙니다.1.1 벡터와 공간‘수를 나열한 것’을 벡터라고 부른다. 위치에 대응시키는 것을 강조한 벡터는 ‘위치벡터’라고 부르는데, 위치라는 해석 외에 원점 0에서 그 위치를 향하는 ‘화살표’라는 뜻도 가진다. 벡터를 화살표로 해석한다면 평면에서 ‘덧셈’과 ‘정수배’도 정의가 가능하다. 이렇게 벡터의 ‘덧셈’과 ’정수배’가 정의된 공간을 ‘선형공간’ 혹은 ‘벡터공간’이라고 부른다.\\[\\vec{v} = \\vec{3e_1} + \\vec{2e_2}\\]‘기저’란 ‘기준이 되는 한 쌍의 벡터’로 벡터 v를 표현할 수 있는 기준이 되는 e1과 e2를 ‘기저 벡터’라고 할 수 있다. 기저가 될 수 있는 조건은 두 가지다. 공간 안의 어떤 벡터v라고 e1,e2,…en 으로 나타낼 수 있다. v를 나타내는 방법이 한 가지 뿐이어야 한다.기저 벡터는 공간의 차원을 정의할 수 있는 기준이기도 하다. 어떤 공간의 기저 벡터의 개수를 가지고 그 공간의 차원을 정의할 수 있다. 차원 = 기저 벡터의 개수 = 좌표의 성분수(공간이 유한 차원일 경우에만 성립한다.)1.2 행렬과 사상‘행렬’이란 수를 직사각형 형태로 나열한 것을 말한다. 특히 행 수와 열 수가 같은 행렬을 정방 행렬이라고 부른다.\\[{n \\choose k} = \\begin{pmatrix} x &amp; y \\\\ y &amp; x \\end{pmatrix}{i \\choose j}A\\]행렬은 덧셈, 정수배가 가능하고 이를 벡터로 나타낼 수도 있다. 위 식은 요인 ‘i, j’와 요소 ‘x, y’로 나타낼 수 있고, 이것이 행렬과 벡터의 곱이다. 행렬과 벡터의 곱에 대해서는 주의할 것들이 있다. 행렬과 벡터의 곱은 벡터 행렬의 열 수(가로폭)가 ‘입력’의 차원수, 행 수(높이)가 ‘출력’의 차원 수 입력의 종벡터를 가로로 넘겨 계산하는 것n차원 벡터 x에 m*n 행렬 A를 곱하면 m차원 벡터 y = Ax가 얻어진다. 즉, 행렬 A를 지정하면 벡터를 다른 벡터에 옮기는 사상이 결정된다. (수학 용어인 ‘변환’이라는 말도 있지만, ‘대등한 것에 이동한다’라는 의미와는 달리 n차원의 공간에서 m차원 공간이라는 다른 세계에 옮기기 때문에 변환보다 넓은 의미인 ‘사상’이라고 표현한다. 글쓴이 주) 또 하나의 특징은 ‘사상이 같다면 행렬도 같다’는 점이다. 즉, 같은 크기의 행렬(사상) A, B가 임의의 벡터 x에 대해 항상 Ax = Bx라면 A = B라는 것이다. 또한 행렬의 법칙에만 맞는다면 사상은 합성(곱)도 가능하다. 하지만 AB = BA인 것은 아니다. 순서가 중요하다.모든 성분이 0인 행렬을 ‘영행렬’이라고 하고, 기호 O로 나타낸다. 영행렬이 나타내는 사상은 모든 것을 원점으로 이동시키는 사상이다.정방행렬에서 ‘\\’ 방향의 대각선 위만 1이고 다른 것은 모두 0인 행렬을 ‘단위행렬’이라고 한다. 기호는 I로 나타낸다. 단위행렬이 나타내는 사상은 ‘아무것도 하지 않는’ 사상이다.정방행렬의 ‘\\’ 방향의 대각선상의 값을 ‘대각성분’이라고 한다. 대각성분 이외의 값은 비대각성분이라고 한다. 이때, 비대각성분이 모두 0인 행렬을 대각행렬이라고 부른다.정방행렬 A에 대해 그 역사상에 대응하는 행렬을 ‘A의 역행렬’이라고 하고, 기호는 $A^{-1}$로 나타낸다. 역행렬은 있을 수도, 없을 수도 있다. 행렬에 의해 다른 두 점 이 같은 점으로 이동한다면 역행렬이 존재하지 않는다.행렬의 종횡에 단락을 넣어 각 구역을 작은 행렬로 간주한 것을 ‘블록행렬’이라고 한다. 블록행렬도 덧셈, 정수배, 곱셈을 계산할 수 있다. 블록행렬은 한 방향으로만 작게 나누는 것도 생각해볼 수 있다. 열로 나눈 것을 ‘열벡터’ 행으로 나눈 것을 ‘행벡터’라고 한다.‘\\’방향의 대각선상 블록이 모두 정방행렬이고, 그 외의 블록이 모두 영행렬인 것을 ‘블록대각행렬’이라고 한다. 그리고 대각성분에 대응하는 행렬을 ‘대각블록’이라고 한다.일반적으로 ‘좌표 변환’은 ’정방행렬 A를 곱하다’라는 형태로 쓸 수 있다. A에는 역행렬이 존재한다. 반대로 역행렬을 지니는 정방행렬 A를 곱하는 것도 좌표변환이라고 해석할 수 있다.행렬 A의 행과 열을 바꿔넣는 것을 A의 ‘전치행렬’이라고 한다. $A^T$라고 쓴다. T 는 Transpose의 T이다.\\[A = \\begin{pmatrix} 2 &amp; 9 &amp; 4 \\\\ 7&amp;5&amp;3 \\end{pmatrix} \\rightarrow A^T = \\begin{pmatrix} 2 &amp; 7\\\\ 9 &amp; 5 \\\\ 4 &amp; 3 \\end{pmatrix}\\]전치의 전치는 원래로 돌아온다. 행렬이 두 개 이상일 경우, $(AB)^T=B^TA^T$로 성립한다.복소수가 들어가있는 복소행렬에서는 보통의 전치 $A^T$보다도 ‘공역전치’로 된다. $A^* = \\bar{A^T}$에서 $\\bar{A}$는 A의 각 성분의 ‘복소공역’을 취한 것이다.1.3 행렬식과 확대율 공간에 있는 어떤 도형에 정방행렬 $A = \\begin{pmatrix} 1.5 &amp; 0 \\ 0 &amp; 0.5\\end{pmatrix}$로 변환하면 도형의 가로는 1.5배 세로는 0.5배로 확대되어 면적은 0.75배가 된다. 면적의 확대율은 도형의 위치와 모양과는 관계가 없다. 이런 면적 확대율에 관한 것을 그 행렬의 ‘행렬식’이라고 한다. 행렬 A의 행렬식은 dat A = 0.75 또는 A = 0.75 라고 표현 할 수 있다. 행렬식은 ‘어느 열의 정수배를 다른 열에 더해도 값이 변하지 않는다’라는 성질이 있다. 대각성분보다 아래쪽이 모두 0인 행렬을 ‘상삼각행렬’이라고 한다. 상삼각행렬의 행렬식은 대각성분의 곱으로 나타낼 수 있다.전치행렬의 행렬식은 원래 행렬의 행렬식과 같다. 즉, $det(A^T) = det A$ 라고 할 수 있다." }, { "title": "프로젝트 정리", "url": "/posts/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%95%EB%A6%AC/", "categories": "자연어처리전문가양성과정", "tags": "자연어처리", "date": "2022-07-01 00:00:00 +0900", "snippet": "팀 프로젝트 구름 Project3영어 -&gt; 한국어 가사 번역기 만들기. 파파고, 구글 번역기 등은 팝송의 영어 가사를 넣고 번역을 시키면 직역으로 번역이 되어서 팝송의 느낌을 그대로 느끼기 어려웠다. 직역보다 초월번역을 할 수 있는 번역기 나의 역할 및 github 아이디어 제공 selenium을 이용한 크롤링, 데이터 전처리 streamlit 구성 HuggingFace를 이용한 model 찾기 프로젝트3-Github 구름 Project2한국어 지문을 읽고 답을 내는 태스크 전체 4조 중 1위. 나의 역할 및 github Lenvenshtein 거리를 사용한 성능 검증 Wandb_sweep을 이용한 파라미터 튜닝, 실험결과 분석 계획 및 방향성 정리 데이터 분석 및 전처리 모델 파인튜닝 프로젝트2-Kaggle 프로젝트2-Github 구름 Project1영어 문장에 대한 이진 분류 문제. 4조 중 3등. 나의 역할 및 github hyper parameter 조정 및 wandb를 이용한 데이터 기록 wandb sweep을 통한 최적의 hyper parameter 탐색 여러가지 learning scheduler 분석 및 선정 task에 맞게 모델 fine-tuning 프로젝트1-Kaggle 프로젝트1-Github 개인 프로젝트 네이버 영화 댓글 감정분석네이버 영화 댓글을 바탕으로 한 감정분석 0.8365의 정확도 네이버_영화_댓글_감정분석 구름 competition와인 quality를 판별하는 competition. competition에 참여한 21명 중 공동 2등을 달성.Goorm competition-KaggleGoorm competition-Github Kaggle 타이타닉Kaggle의 타이타닉 참여. 0.79186 달성. 타이타닉-Github" }, { "title": "밑바닥부터 시작하는 딥러닝1(3)", "url": "/posts/%EB%B0%91%EB%B0%94%EB%8B%A51(3)/", "categories": "개인공부", "tags": "자연어처리", "date": "2022-07-01 00:00:00 +0900", "snippet": "Notice밑바닥부터 시작하는 딥러닝&lt;사이토 고키&gt;, &lt;개앞맵시&gt;, &lt;한빛미디어&gt;를 바탕으로 공부한 내용임을 밝힙니다. 챕터2부터 시작합니다.3.1 퍼셉트론에서 신경망으로신경망은 ‘입력층’, ‘출력층’, ’은닉층’으로 나뉘어져있다. 은닉층의 뉴런은 입력층과 출력층과는 달리 눈에 보이지 않기 때문에 ‘은닉’이라고 한다. 신경망은 퍼셉트론과 굉장히 비슷한 구조다. 퍼셉트론을 하나의 식으로 나타내면 \\(y = h(b+w_1x_1+w_2x_2)\\)로 나타낼 수 있다.\\[h(x)=\\begin{cases}0(x\\le\\ 0)\\\\1(x&gt;0)\\end{cases}\\]즉, 입력신호의 총합이 \\(h(x)\\)라는 함수를 거쳐 변환되어, 그 변환된 값이 \\(y\\)의 출력이 되는 것을 보여준다. 이처럼 입력신호의 총합을 출력 신호로 변환하는 함수는 일반적으로 ‘활성화 함수(Activation Function)’라 합니다. ‘활성화’라는 이름이 말해주듯, 활성화 함수는 입력신호의 총합이 활성화를 일으키는지를 정하는 역할을 한다.3.2 활성화 함수활성화 함수는 임계값을 경계로 출력이 바뀌는데, 이런 함수를 ‘계단 함수’라고 한다. 즉, 활성화 함수로 쓸 수 있는 여러 후보 중에서 퍼셉트론은 계단 함수를 채용하고 있다.계단 함수는 위의 식처럼 입력이 0을 넘으면 1을 출력하고, 그외에는 0을 출력하는 함수다. 이러한 계단 함수를 파이썬으로 단순하게 구현하면 다음과 같다.def step_function(x):\ty = x &gt; 0\treturn y.astypr(np.int)‘시그모이드 함수(Sigmoid function)’는 신경망에서 자주 이용하는 활성화 함수이다. 시그모이드 함수 를 식으로 나타내면 다음과 같다.\\[h(x) = {1 \\over 1+ \\exp(-x)}\\]\\(\\exp(-x)\\)는 \\(e^{-x}\\)를 뜻하며, \\(e\\)는 자연상수로 2.7182… 의 값을 갖는 실수다. 신경망에서는 활성화 함수로 시그모이드 함수를 이용하여 신호를 변환하고, 그 변환된 신호를 다음 뉴런에 전달한다.시그모이드 함수도 파이썬으로 구현할 수 있다.def sigmoid(x):\t\treturn 1 / (1 + np.exp(-x))시그모이드 함수와 계단 함수를 비교해보면 가장 먼저 느껴지는 차이점은 매끄러움 일 것이다. 시그모이드 함수(실선)는 부드러운 곡선이다. 반면에 계단 함수(점선)는 입력 0을 경계로 출력이 급작스럽게 바뀐다. 즉, 계단 함수가 0과 1중 하나의 값만 돌려주는 반면 시그모이드 함수는 실수를 돌려준다. 시그모이드 함수의 이 매끈함은 신경망 학습에서 아주 중요한 역할을 한다.두 함수는 공통점도 가진다. 큰 관점에서 보면 둘은 같은 모양을 가진다. 둘 다 입력이 작을 때의 출력은 0에 가깝고, 입력이 커지면 출력이 1에 가까워지는 구조다. 출력이 0에서 1사이라는 것도 둘의 공통점이다.두 함수 모두 ‘비선형 함수’라는 것도 공통점이다. 비선형 함수는 문자 그대로 ‘선형이 아닌’ 함수다. 즉, 직선 1개로는 그릴 수 없는 함수다. 신경망에서는 활성화 함수로 비선형 함수를 사용해야 한다. 선형 함수의 문제는 층을 아무리 깊게 해도 ‘은닉층이 없는 네트워크’로도 똑같은 기능을 할 수 있다는 데 있다. 그래서 층을 쌓는 혜택을 얻고 싶다면 활성화 함수로는 반드시 비선형 함수를 사용해야 한다.계단 함수, 시그모이드 외에도 활성화 함수는 여러 가지가 있다. 그 중 하나는 ReLU(Rectified Linear Unit)함수다. ReLU는 입력이 0 을 넘으면 그 입력을 그대로 출력하고, 0이하면 0을 출력하는 함수다.수식으로는 다음과 같이 쓸 수 있다.\\[h(x)=\\begin{cases}x(x &gt; 0)\\\\0(x\\le0)\\end{cases}\\]ReLu 함수는 파이썬으로도 간단하게 구현할 수 있다.def relu(x):\t\treturn np.maximum(0,x)3.4 3층 신경망 구현하기3층 신경망의 입력층에서 ‘1층의 첫 번째 뉴런’으로 가는 신호를 보자.편향을 뜻하는 뉴런인 1이 추가됐다. 1층의 \\(a_1^{(1)}\\)을 수식으로 나타내면 \\(a_1^{(1)}\\)은 가중치를 곱한 신호 두 개와 편향을 합해서 계산한다.\\[a_1^{(1)} = w_{11}^{(1)}x_1 + w_{(12)}^{(1)}x_2 + b_1^{(1)}\\]여기에서 행렬의 곱을 이용하면 1층의 ‘가중치 부분’을 다음식처럼 간소화할 수 있다.\\[A^{(1)} = XW^{(1)} + B^{(1)}\\]이때 행렬 $A^{(1)}, X,B^{(1)},W^{(1)}$은 다음과 같다.\\[A^{(1)} = \\begin{pmatrix} a^{(1)}_1 \\ a^{(1)}_2\\ a^{(1)}_3\\end{pmatrix} \\ X^{(1)} = \\begin{pmatrix} x^{(1)}_1 \\ x^{(1)}_2\\ \\end{pmatrix}\\ B^{(1)} = \\begin{pmatrix} b^{(1)}_1 \\ b^{(1)}_2\\ b^{(1)}_3\\end{pmatrix}\\\\W^{(1)} = \\begin{pmatrix} w^{(1)}_{11} \\ w^{(1)}_{21}\\ w^{(1)}_{31} \\\\w^{(1)}_{12} \\ w^{(1)}_{22}\\ w^{(1)}_{32} \\end{pmatrix}\\]1층을 파이썬으로 구현해보자.X = np.array([1.0,0.5])W1 = np.array([[0.1,0.3,0.5],[0.2,0.4,0.6]])B1 = np.array([0.1,0.2,0.3])A1 = np.dot(X, W1) +B1위 그림은 은닉층을 표현한다. 가중치의 합(가중 신호와 편향의 총합)을 a로 표기하고 활성화 함수 h()로 변환 된 신호를 z로 펴기한다. 여기에서는 활성화 함수로 시그모이드 함수를 사용하기로 한다. 이를 파이썬으로 구현하면 다음과 같다.Z1 = sigmoid(A1)여기서 sigmoid함수는 앞에서 정의한 함수다.이어서 1층에서 2층으로 가는 과정이다.W2 = np.array([[0.1,0.4],[0.2,0.5],[0.3,0.6]])B2 = np.array([0.1,0.2])A2 = np.dot(Z1,W2) + B2Z2 = sigmoid(A2)1층의 출력인 Z1이 2층의 입력이 된다는 점을 제외하면 1층과 구현이 같다. 마지막으로 2층에서 출력층까지의 신호전달도 구현해보자.def identity_function(x):\t\treturn xW3 = np.array([[0.1,0.3],[0.2,0.4]])B3 = np.array([0.1,0.2])A3 = np.dot(Z2,W3) + B3Y = identity_function(A3)여기서 identity_function()은 항등 함수로, 출력층의 활성화 함수로 이용했다. 항등함수는 입력을 그대로 출력하는 함수다.지금까지 구현들을 정리하면 다음과 같다.def init_network():\t\tnetwork = {}\t\tnetwork['W1'] = np.array([[0.1,0.3,0.5],[0.2,0.4,0.6]])\t\tnetwork['B1'] = np.array([0.1,0.2,0.3])\t\tnetwork['W2'] = np.array([[0.1,0.4],[0.2,0.5],[0.3,0.6]])\t\tnetwork['B2'] = np.array([0.1,0.2])\t\tnetwork['W3'] = np.array([[0.1,0.3],[0.2,0.4]])\t\tnetwork['B3'] = np.array([0.1,0.2])\t\treturn networkdef forward(network, x):\t\tW1, W2, W3 = network['W1'], network['W2'], network['W3']\t\tB1, B2, B3 = network['B1'], network['B2'], network['B3']\t\tA1 = np.dot(X, W1) + B1\t\tZ1 = sigmoid(A1)\t\tA2 = np.dot(Z1,W2) + B2\t\tZ2 = sigmoid(A2)\t\tA3 = np.dot(Z2,W3) + B3\t\ty = identity_function(A3)\t\t\t\treturn ynetwork = init_network()x = np.array([1.0, 0.5])y = forward(network, x)print(y) #[0.31682708 0.69627909] 여기서 init_network()와 forward()라는 함수를 정의했다. init_network()함수는 가중치와 편향을 초기화하고 이들을 딕셔너리 변수인 network에 저장한다. 그리고 network에는 각 층에 필요한 매개변수들이 저장된다. 그리고 forward() 함수는 입력 신호를 출력으로 변환하는 처리 과정을 모두 구현하고 있다.3.5 출력층 설계하기" }, { "title": "밑바닥부터 시작하는 딥러닝1(2)", "url": "/posts/%EB%B0%91%EB%B0%94%EB%8B%A51(2)/", "categories": "개인공부", "tags": "자연어처리", "date": "2022-07-01 00:00:00 +0900", "snippet": "Notice밑바닥부터 시작하는 딥러닝&lt;사이토 고키&gt;, &lt;개앞맵시&gt;, &lt;한빛미디어&gt;를 바탕으로 공부한 내용임을 밝힙니다. 챕터2부터 시작합니다.2.1 퍼셉트론이란?‘퍼셉트론’이은 다수의 신호를 입력으로 받아 하나의 신호를 출력하는 것이다. 신호란 전류나 강물처럼 흐름이 있는 것이다. 다만, 실제 전류와는 달리 페셉트론 신호는 ‘흐른다/안 흐른다’의 두 가지 값을 가진다. ‘신호가 흐른다’는 1로, ‘신호가 흐르지 않는다’는 0으로 표현한다.그림의 \\(x_1\\)과 \\(x_2\\)는 입력신호, \\(y\\)는 출력 신호, \\(w_1\\), \\(w_2\\)는 가중치를 뜻한다. 그림의 원은 ‘뉴런’혹은 ‘노드’라고 한다. 입력 신호가 뉴런에 보내질 때는 각각 고유한 ‘가중치’가 곱해진다\\((w_1x_1, w_2x_2)\\). 뉴런에서 보내온 신호의 총합이 정해진 한계를 넘어설 때만 1을 출력한다. 그 한계는 ‘임계값’이라고 하며, \\(\\theta\\) 기호로 나타낸다.2.2 단순한 논리 회로AND 게이트는 입력이 둘이고 출력은 하나다. 위 진리표에서 볼 수 있듯이 입력이 모두 1일 때만 1을 출력하고, 그 외에는 0을 출력한다. AND게이트를 수식으로 나타내면\\[y=\\begin{cases}0(w_1x_1+w_2x_2\\le\\theta)\\\\1(w_1x_1+w_2x_2&gt;\\theta)\\end{cases}\\]로 나타낼 수 있다. 이를 파이썬으로 구현하면 다음과 같다.def AND(x1,x2):\tw1, w2, theta = 0.5, 0.5, 0.7\ttmp = x1*w1 + x2*w2\tif tmp &lt;= theta:\t\t\treturn 0 \telif tmp &gt; theta:\t\t\treturn 1수식에서 \\(\\theta\\)를 \\(-b\\)로 치환하면 다음과 같이 나타낼 수 있다.\\[y=\\begin{cases}0(b+w_1x_1+w_2x_2\\le\\ 0)\\\\1(b+w_1x_1+w_2x_2&gt;0)\\end{cases}\\]이 수식에서 \\(b\\)를 ‘편향’이라고 한다. 이렇게 퍼셉트론은 입력 신호에 가중치를 곱한 값과 편향을 합하여, 그 값이 0을 넘으면 1을 출력하고 그렇지 않으면 0을 출력한다.2.3 퍼셉트론 구현하기수식을 파이썬으로 구현해보면def AND(x1,x2):\tx = np.array([x1, x2])\tw = np.array([0.5,0.5])\tb = -0.7\ttmp = np.sum(w*x) + b\tif tmp &lt;= 0:\t\t\treturn 0 \telif tmp &gt; 0:\t\t\treturn 1으로 나타낼 수 있다. 여기서 w는 각 입력 신호가 결과에 주는 영향력(중요도)을 조절하는 매개변수고, 편향은 뉴런이 얼마나 쉽게 활성화(결과로 1을 출력)하느냐를 조정하는 매개변수다.NAND 게이트는 Not AND를 의미하며, 출력이 AND 게이트의 출력을 뒤집은 것과 같다. 즉, 입력 모두 1일 때만 0을 출력하고 그 외에는 1을 출력한다. AND게이트처럼 파이썬으로 구현하면 다음과 같다.def NAND(x1,x2):\tx = np.array([x1,x2])w = np.array([-0.5,-0.5])b = 0.7tmp = np.sum(w*x) + bif tmp &lt;= 0:\treturn 0else:\treturn 1OR게이트는 AND게이트, NAND게이트와는 달리 입력 신호 중 하나 이상이 1이면 출력이 1이 되는 논리 회로다.def OR(x1,x2):\tx = np.array([x1,x2])\tw = np.array([0.5,0.5])\tb = -0.2\ttmp = np.sum(w*x) + b\tif tmp &lt;= 0:\t\treturn 0\telse:\t\treturn 1여기서 우리가 알 수 있는 것은 AND, NAND, OR게이트 모두 같은 구조의 퍼셉트론이고, 차이는 가중치 매개변수의 값뿐이라는 것이다. 파이썬으로 작성한 회로들의 tmp는 모두 같다.2.4 퍼셉트론의 한계하지만 논리회로를 모두 표현하기에 퍼셉트론은 한계가 있다. XOR게이트는 ‘배타적 논리합’이라는 논리 회로다. \\(x_1,x_2\\) 중 한쪽이 1일 때만 1을 출력한다.퍼셉트론이 한계를 갖는 이유는 퍼셉트론은 직선 하나로 나눈 영역만 표현할 수 있다는 한계가 있기 때문이다. XOR회로는 곡선으로 표현되야하기 때문에 퍼셉트론으로 표현이 불가능한 것이다. XOR회로처럼 곡선의 영역을 ‘비선형’영역, 직선의 영역을 ‘선형’영역이라고 한다.2.5 다층 퍼셉트론이 출동한다면하지만 이런 한계를 뛰어넘을 수 있는 방법이 있다. 퍼셉트론으로는 ‘다층 퍼셉트론’을 만들 수 있기 때문이다. XOR게이트를 만들 수 있는 방법 중 하나는 AND게이트, NAND게이트, OR게이트를 조합하는 방법이다.그림과 같이 NAND게이트, OR게이트를 입력에 AND게이트를 출력에 놓고 연결하면 XOR게이트를 구현할 수 있다. 이를 파이썬으로 구현해보면def XOR(x1,x2):\ts1 = NAND(x1,x2)\ts2 = OR(x1,x2)\ty = AND(s1,s2)\treturn y로 구현할 수 있다. XOR게이트는 위 그림처럼 2층 구조다. 입력층인 0층 NAND, OR게이트가 있는 1층, AND게이트와 출력층인 2층. XOR게이트의 동작을 자세히 보면 다음과 같다. 1층의 뉴런이 2층의 뉴런으로 신호를 보내고, 2층의 뉴런은 y를 출력한다. 0층의 두 뉴런이 입력 신호를 받아 1층의 뉴런으로 신호를 보낸다.즉, 단층 퍼셉트론과는 달리 다층 퍼셉트론에서는 퍼셉트론끼리 출력값과 입력값을 전달한다." }, { "title": "자연어 처리 전문가 양성 과정_프로젝트3", "url": "/posts/%EC%9E%90%EC%97%B0%EC%96%B4-%EC%B2%98%EB%A6%AC-%EC%A0%84%EB%AC%B8%EA%B0%80-%EC%96%91%EC%84%B1-%EA%B3%BC%EC%A0%95_%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B83/", "categories": "자연어처리전문가양성과정", "tags": "자연어처리", "date": "2022-06-30 00:00:00 +0900", "snippet": "프로젝트3 - Github프로젝트3은 나만의 영-한 번역기를 만드는 것이었습니다. 저는 파파고, 구글 번역기 등은 팝송의 영어 가사를 넣고 번역을 시키면 직역으로 번역이 되어서 팝송의 느낌을 그대로 느끼기 어렵다는 것에서 착안해 초월번역을 할 수 있는 가사 번역기를 만들자고 제안했습니다.우선은 데이터 셋을 만들었습니다. K팝이 해외에서 인기인 덕에 해외 팬들이 직접 한국어를 영어로 번역한 사이트가 있었습니다. 뿐만 아니라 국내 팝송 팬들이 직접 한글로 번역한 사이트도 있었습니다. 이런 여러 가사사이트들을 selinium을 사용해 크롤링했습니다. 총 약 26000개 수집했습니다.전처리를 통해 크롤링한 데이터를 정제하고, 잘못된 번역은 없는지, 정제에서 잘못된 데이터는 없는지 일일이 확인했습니다. 생각보다 많은 데이터들이 전처리에서 사라져서 저희 팀은 데이터를 늘리고, 노이즈를 줄이기 위한 방법으로 back translation기법을 사용했습니다. Bert - KoGPT2, KoGPT2 - Bert로 만든 가사 번역기로 팝송, 국내가요를 back translation시켜 데이터를 총 24000개로 늘릴 수 있었습니다.하지만 Bert - KoGPT2, KoGPT2 - Bert의 가사 번역기가 높은 성능을 보이지 않고, 번역도 생각보다는 떨어진다고 판단됐습니다. 허깅페이스를 이용해 어떤 모델이 좋을지 조사를 했습니다. 저희 팀은 Facebook의 m2m100을 사용하기로 했습니다. m2m100은 중간 언어로 영어를 통하지 않고 100개 언어를 직접 번역할 수 있고, 고품질의 양방향 번역데이터가 있다는 점이 강점입니다. 저희 팀의 태스크가 유연성이 있는 번역이었기 때문에 m2m100을 채택하는 것이 좋다고 생각했습니다.저희는 구글코랩을 사용했기 때문에 한정된 GPU자원으로 모델을 돌려야해서 batch size나 epoch에 한계가 있었습니다. 때문에 최적의 learning-rat, batch size, epoch를 찾기 위해 시간이 오래 걸렸고 한계가 있지만, 저희가 찾은 최적의 수치들을 적용했습니다.후처리도 했습니다. 출력에서 효율성을 높이기 위해 beam기법을 사용했고, 출력에서 원하는 번역을 제외하고도 추가되는 출력이 있어서 길이를 제한하기 위해 max_length도 조절했습니다. 뿐만 아니라 단어가 연속적으로 중복되는 경우 똑같이 번역되는 것을 방지하기 위해서 ngram 기법을 사용했습니다.이후 streamlit을 통해 demo앱을 만들었습니다. 앱은 BGM, 가사 입력(input), 입력언어-출력언어 설정 selectbox, 번역된 가사 출력(output), 번역된 가사를 음성출력으로 구성했습니다.아쉬웠던 점은 동원할 수 있는 자원이 더 많았다면, 시간이 더 충분했다면 더 정확도가 높은 가사 번역기를 만들 수 있었을 것 같다는 점과 streamlit을 배우고 만들어 본 것은 좋았지만 어플이나 사이트로 만들어 볼 수 있었을 거라고 생각합니다. 또, 저희 팀은 m2m100을 이용했기 때문에 영어-한국어뿐만 아니라 다양한 언어도 추가할 수 있었을 것 같습니다. 다국적 가사 번역기로도 발전시킬 수 있었다고 생각합니다." } ]
